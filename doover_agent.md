# Doover App Authoring Agent (agent.md)

> **Purpose**: This file tells an LLM exactly how to create *Docker device apps* for **Doover** using the official template repository and the **pydoover** library. It encodes folder layout, coding conventions, config schema, and end‑to‑end build/run steps so the LLM can output production‑ready repos that slot straight into Doover’s tooling and device fleet.

---

## 0) “Definition of Done”

An app is **done** when the repository the LLM emits contains **at minimum**:

* `pyproject.toml` with a proper package name and a dependency on `pydoover` (and optional extras if needed).
* `doover_config.json` **generated by the Doover CLI** (see below) via `doover config-schema export` — **never hand‑edit this file**.
* `src/<package_name>/` with:

  * `application.py` – subclass of `pydoover.docker.Application` implementing `setup()` and `main_loop()`.
  * `app_config.py` – a `pydoover.config.Schema` describing all configuration items users set in Doover.
  * `app_ui.py` (optional but encouraged) – UI definitions built with pydoover’s UI API.
  * `app_state.py` (optional) – state machine(s) or orchestration logic (e.g., safety interlocks).
* `Dockerfile` that builds a minimal runtime image and starts the app correctly.
* `simulator/` with at least `app_config.json` and `docker-compose.yml` to run the app locally.
* `tests/` with a smoke test that imports the package and (ideally) steps the app once in `test_mode`.

**Use the Doover CLI at the right times (summary):**

1. **Scaffold** the repo: `doover app create` (interactive; choose Docker app template). 2) **Generate/refresh** `doover_config.json`: `doover config-schema export`. 3) **Run** locally: `doover app run`.

The repo **must run** with:

```bash
# From repo root
uv sync       # or: pip install -e .
python -m <package_name>.application  # local run

# or with Doover CLI (recommended where available)
doover app run
```

---

## 1) Use the official template + Doover CLI

**Always start** from Doover’s template layout, and **scaffold with the Doover CLI**. The creation flow should be:

1. From an empty directory (or your workspace), run:

   ```bash
   doover app create
   ```

   Follow the prompts to name the app/repo and select the **Docker application** template based on the official `app-template`.
2. Commit the freshly generated repo (the CLI places the correct structure and bootstrap files for you).
3. Implement your code (sections below), then **export the config schema** to `doover_config.json` using:

   ```bash
   doover config-schema export
   ```

   This validates your `app_config.py` and (re)generates `doover_config.json` (do **not** hand‑edit).
4. Run locally using:

   ```bash
   doover app run
   ```

Your output should mirror this structure (file names may vary by package name):

```
├─ .github/workflows/        # CI (build, lint, publish)
├─ src/<package>/            # your app’s Python package
│  ├─ application.py         # main entry point (subclass Application)
│  ├─ app_config.py          # pydoover.config.Schema
│  ├─ app_ui.py              # optional UI (Variables, Interactions)
│  └─ app_state.py           # optional state machines
├─ tests/                    # pytest tests
├─ simulator/
│  ├─ app_config.json        # example config values for local run
│  └─ docker-compose.yml     # run alongside platform/device agent if needed
├─ Dockerfile                # build a device image for this app
├─ doover_config.json        # **generated by CLI** (do not edit by hand)
├─ pyproject.toml            # package + deps (pydoover)
└─ README.md                 # what the app does and how to run it
```

### Naming

* Python package: **snake_case** (e.g., `hydraulics_controller`).
* App repo name: **kebab-case** (e.g., `hydraulics-controller`).
* The app’s **`app_key`** is autogenerated by `pydoover` at runtime; display name lives in `doover_config.json`.
* Python package: **snake_case** (e.g., `hydraulics_controller`).
* App repo name: **kebab-case** (e.g., `hydraulics-controller`).
* The app’s **`app_key`** is autogenerated by `pydoover` at runtime; display name lives in `doover_config.json`.

---

## 2) pyproject.toml (minimum spec)

Use **Python 3.11+**. Prefer **uv** for dependency management, but pip is fine.

```toml
[project]
name = "hydraulics-controller"      # change per app
version = "0.1.0"
description = "A Doover app for <what it does>"
readme = "README.md"
requires-python = ">=3.11"
license = { text = "Apache-2.0" }
authors = [{ name = "<Your Org>", email = "dev@your.org" }]

# Core dependency – pydoover is required for all device apps
# If you are NOT using Doover’s base image for gRPC, include the [grpc] extra
# e.g. "pydoover[grpc] >= 0.4.0"
dependencies = [
  "pydoover >= 0.4.0"
]

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]
```

> If the app talks to Modbus or similar gRPC interfaces and your base image doesn’t already include gRPC pins, use `pydoover[grpc]`.

---

## 3) doover_config.json (metadata)

**Source of truth:** `doover_config.json` is **generated and updated exclusively** by the Doover CLI from your configuration schema — **never edit this file manually.**

Generate/refresh it anytime your schema changes:

```bash
doover config-schema export
```

This validates your `app_config.py` and writes a consistent `doover_config.json` at the repo root.

**What it contains (for orientation only; do not hand‑edit):**

* Name, short/long description, categories
* Image name / registry
* Owner org
* Optional dependencies

---

## 4) Application entry point (`application.py`)

Your app must **subclass** `pydoover.docker.Application`.

```python
# src/hydraulics_controller/application.py
from pydoover.docker import Application, run_app
from pydoover.config import Schema
from .app_config import AppConfig  # your Schema subclass

class HydraulicsController(Application):
    """Main app – override setup() and main_loop()."""

    loop_target_period = 1.0  # seconds between main loop iterations

    async def setup(self) -> None:
        # Called once after containers are connected and UI is ready.
        # Good place to wire subscriptions, build UI, set initial tags.
        self.set_tag("ready", True)

        # Example: listen to a Device Agent channel
        async def on_cmd(name, data):
            if isinstance(data, dict) and data.get("action") == "start_pump":
                await self.platform_iface.set_do(0, True)
                await self.device_agent.publish_to_channel("events", {"event": "pump_started"})
        self.device_agent.add_subscription("commands", on_cmd)

    async def main_loop(self) -> None:
        # Keep loops short; call awaitable IO methods
        # Example: poll an analogue input and publish/Tag
        ai0 = await self.platform_iface.get_ai(0)
        if ai0 is not None:
            self.set_tag("pressure_bar", round(ai0, 2))
        await self.wait_for_interval(self.loop_target_period)  # helper from base class

if __name__ == "__main__":
    run_app(HydraulicsController(config=Schema.from_dataclass(AppConfig())))
```

### What the base class gives you

* `device_agent`: publish/subscribe to channels; get aggregates; sync checks.
* `platform_iface`: analog/digital IO, scheduling outputs, system info, GPS, reboot/shutdown.
* `modbus_iface`: read/write registers, subscribe to reads, multi‑bus configs.
* `ui_manager`: declare Variables, Parameters, Interactions for the Doover UI.
* `set_tag()/get_tag()` and global versions for cross‑app flags.
* `check_can_shutdown()` and `on_shutdown_at()` hooks to coordinate safe device shutdown.

> **Guideline**: Never block the main loop. Use short awaits and store work/results in state that the next loop consumes.

---

## 5) App configuration (`app_config.py`)

Define a schema to type‑check and document your app’s settings. Users supply these via Doover.

```python
# src/hydraulics_controller/app_config.py
from dataclasses import dataclass
from pydoover.config import Schema, Number, Boolean, String

@dataclass
class AppConfig(Schema):
    # Examples – keep names stable; UI can render these as Parameters
    target_pressure: Number = Number(
        display_name="Target Pressure (bar)",
        default=120.0,
        minimum=0,
        maximum=250
    )
    enable_interlocks: Boolean = Boolean(
        display_name="Enable Interlocks",
        default=True
    )
    site_name: String = String(
        display_name="Site Name",
        default="Unnamed"
    )
```

> If you need Modbus, define a `ManyModbusConfig` or `ModbusConfig` entry here and the interface will auto‑load it from config.

---

## 6) Optional UI (`app_ui.py`)

Expose variables and interactions for operators.

```python
# src/hydraulics_controller/app_ui.py
from pydoover.ui import UIManager, NumericVariable, Action, Slider

class HydraulicsUI:
    def build(self, ui: UIManager):
        pressure = NumericVariable("pressure_bar", display_name="Pressure (bar)")
        ui.add_variable(pressure)

        set_target = Slider("target_pressure", 0, 250, step=1, display_name="Set Target")
        ui.add_parameter(set_target)

        start = Action("start_pump", label="Start Pump")
        ui.add_interaction(start)
```

Call this from `setup()` after `ui_manager` is ready.

---

## 7) Common patterns by app type

Use these as recipes when the prompt implies a certain device capability.

### 7.1 Analogue sensor (e.g., **4‑20mA sensor**)

* Read AI pin(s) via `platform_iface.get_ai()`.
* Map sensor engineering units and set UI `NumericVariable`.
* Publish to a `telemetry` channel periodically.

```python
ai = await self.platform_iface.get_ai(0)
if ai is not None:
    value = map_reading(ai, in_min=4, in_max=20, out_min=0, out_max=1000)  # if using a transmitter scale
    self.set_tag("level_mm", value)
    await self.device_agent.publish_to_channel("telemetry", {"level_mm": value})
```

### 7.2 Pulse/flow counter (e.g., **flow‑pulse‑counter**, **rain gauge**)

* `counter = self.platform_iface.get_new_pulse_counter(di=0, edge="rising", callback=on_pulse)`
* In `on_pulse`, compute rate with `counter.get_pulses_per_minute()` and integrate volume.

### 7.3 Modbus gateway/control (e.g., **enip‑cip‑interface**, **generator‑control**)

* Define modbus buses in `AppConfig`.
* Use `modbus_iface.read_registers(...)` / `write_registers(...)`.
* For polling, prefer `add_read_register_subscription(...)` with a short callback.

### 7.4 Connectivity/utilities (e.g., **wifi‑rotate**, **starlink‑manager**)

* Focus on UI interactions + system tags.
* Gate disruptive actions with `check_can_shutdown()`.

### 7.5 Camera/ML (e.g., **camera‑inference**, **image‑loader**)

* Run the inference task in a background coroutine started in `setup()`.
* Publish detections to a channel; surface quick controls in `app_ui.py`.

---

## 8) Dockerfile (baseline)

Keep images small and deterministic; use a Python base with 3.11+. If your environment already provides Doover’s gRPC sidecars, plain `pydoover` is enough; otherwise add the `[grpc]` extra.

```dockerfile
# Dockerfile
FROM python:3.11-slim

# Install UV (faster, reproducible builds)
RUN pip install --no-cache-dir uv

# Workdir and copy
WORKDIR /app
COPY pyproject.toml uv.lock* ./
RUN uv sync --inexact --no-dev
COPY src ./src

# Default: run module as an app
ENV PYTHONPATH=/app/src
ENTRYPOINT ["python", "-m", "hydraulics_controller.application"]
```

> If you standardize on a Doover base image in your fleet, swap the `FROM` for that and delete the `uv` bootstrap accordingly.

---

## 9) Simulator (`simulator/`)

Provide quick‑start local runs.

**`simulator/app_config.json`** –

```json
{
  "target_pressure": 120,
  "enable_interlocks": true,
  "site_name": "Bench Rig"
}
```

**`simulator/docker-compose.yml`** – bring up your app and any sidecars (e.g., platform/modbus interfaces if you mock them).

```yaml
services:
  app:
    build: ..
    environment:
      - DOOVER_APP_CONFIG=/sim/app_config.json
    volumes:
      - ./app_config.json:/sim/app_config.json:ro
    network_mode: host   # if you rely on local sidecars exposing gRPC ports
```

---

## 10) Tests

* Always include `tests/test_imports.py` that verifies the package imports.
* Add a `test_app.py` that runs one loop in `test_mode` and asserts key tags are set.

```python
import asyncio
from <package>.application import HydraulicsController
from pydoover.docker import run_app
from pydoover.config import Schema

async def test_single_loop():
    app = HydraulicsController(config=Schema(), test_mode=True)
    asyncio.create_task(run_app(app, start=False))
    await app.wait_until_ready()
    await app.next()  # advance main loop once
    assert app.get_tag("ready") is True
```

---

## 11) App wiring checklists

**Cloud & channels**

* [ ] Subscriptions registered in `setup()` with short, safe callbacks.
* [ ] Telemetry published to a stable channel name.
* [ ] Use `max_age=-1` only for urgent one‑off messages.

**IO & safety**

* [ ] `check_can_shutdown()` blocks shutdown while unsafe.
* [ ] Use `schedule_do()`/`schedule_ao()` for time‑boxed outputs.
* [ ] Debounce DI/edge logic with `get_di_events()` as needed.

**UI**

* [ ] Parameters represent every config knob users may change.
* [ ] Variables mirror important tags (status, alarms, rates, setpoints).

**Config**

* [ ] Every `app_config` field has a default and sensible bounds.
* [ ] If Modbus used, buses defined in config using provided classes.

**Docker**

* [ ] Deterministic `pyproject.toml` + lock file committed.
* [ ] Minimal runtime image, clear ENTRYPOINT.

---

## 12) Developer ergonomics & style

* **Async‑first**: Prefer async interfaces; don’t block the loop.
* **Small functions**: callbacks under ~30 lines; extract helpers.
* **Idempotence**: `setup()` can be called once—treat side effects carefully.
* **Tags as API**: Treat tags as your device’s external status surface.
* **Fatal logging**: Fail fast on unrecoverable hardware/config errors.
* **Config gating**: Validate required config on start; refuse to run if invalid.

---

## 13) CI & release

* Add a GitHub Action that lints (Ruff), runs tests (pytest), and builds/pushes a Docker image on tags.
* Image tag strategy: `:sha-<short>` for CI, `:X.Y.Z` for releases, `:latest` only for demo/dev.

---

## 14) Prompts for the LLM (copy/paste)

**“Create a new Doover app”**

> Use the Doover template structure. Package name `<package>`. App name "<Pretty Name>". Implement `application.py` subclassing `pydoover.docker.Application`. Provide `app_config.py` with Schema for: <list>. Add simple UI in `app_ui.py`. Add `simulator/` with compose + config. Dockerfile must start `python -m <package>.application`. Include `tests/` with one loop in `test_mode`. Add `doover_config.json` with `image`, `ownerOrg`, `containerRegistry`, descriptions.

**“Add Modbus polling”**

> Extend `app_config.py` to include a `ManyModbusConfig`. In `setup()`, call `modbus_iface.add_read_register_subscription(...)` with a short callback that updates tags. Provide a `write_registers(...)` helper and a UI action to trigger it.

**“Implement a pulse counter”**

> Use `platform_iface.get_new_pulse_counter(...)` with a callback that updates tags: cumulative total, pulses/minute, last pulse age. Expose Variables and a Parameter for `K‑factor` (units/pulse).

**“Safely control a DO”**

> Provide `check_can_shutdown()` to refuse shutdown when output must be off; use `schedule_do(pin, state, seconds)` instead of long holds. Add a UI Action to toggle with a timer.

---

## 15) What to copy from example repos

When the user’s prompt resembles these repos, mirror their patterns:

* **4‑20mA sensor** – single AI read, engineering units, periodic publish.
* **flow‑pulse‑counter / analog‑rain‑gauge** – pulse counters with integration + rate windows.
* **generator‑control / hydraulics‑controller / irrigation‑gate‑control** – stateful control loops, DO interlocks, operator UI.
* **enip‑cip‑interface** – bus protocol bridge; keep callbacks tiny, add retry/backoff.
* **camera‑inference / image‑loader** – background workers; decouple inference step from UI updates.
* **wifi‑rotate / starlink‑manager / power‑management** – device connectivity utilities; use tags to expose current provider/state.

---

## 16) Local run & production run

**Local (Python)**

```bash
uv sync
python -m <package>.application --config ./simulator/app_config.json
```

**With Doover CLI (preferred)**

```bash
doover app run --config ./simulator/app_config.json
```

**Scaffold with Doover CLI**

```bash
doover app create   # interactive, select Docker app template
```

**Generate/refresh config (CLI)**

```bash
doover config-schema export
```

**Docker**

````bash
docker build -t ghcr.io/<org>/<repo>:dev .
docker run --rm --network host ghcr.io/<org>/<repo>:dev
```bash
uv sync
python -m <package>.application --config ./simulator/app_config.json
````

**With Doover CLI**

```bash
doover app run --config ./simulator/app_config.json
```

**Docker**

```bash
docker build -t ghcr.io/<org>/<repo>:dev .
docker run --rm --network host ghcr.io/<org>/<repo>:dev
```

> In production, publish to your registry with a semver tag and update `doover_config.json:image` accordingly.

---

## 17) Troubleshooting checklist

* App doesn’t start? Verify Python 3.11+, `pydoover` version, and entrypoint module path.
* No IO? Ensure platform (and modbus, if any) sidecars are reachable; if local, run with `--network host`.
* UI empty? Ensure `ui_manager` constructs variables/parameters before `setup()` completes.
* Channels silent? Confirm `device_agent` has synced channels; wait or use `wait_until_ready()` before publishing.
* Shutdown loops? Implement `check_can_shutdown()` and log decisions explicitly.

---

## 18) Keep it tight

* **No long‑running blocking calls** in callbacks or `main_loop()`.
* **Short, predictable loops**; use `wait_for_interval()`.
* **All external effects logged** (outputs, writes, critical decisions).
* **Deterministic builds** (pin deps, commit lock files).

*That’s it. If the prompt is vague, prefer the minimal working app above, plus simulator, then iterate with the user.*
